{"ast":null,"code":"\"use strict\";\n/* global module, require */\n\nmodule.exports = function () {\n  \"use strict\"; // Get a promise object. This may be native, or it may be polyfilled\n\n  var ES6Promise = require(\"./promise.js\");\n  /**\n   * thatLooksLikeAPromiseToMe()\n   *\n   * Duck-types a promise.\n   *\n   * @param {object} o\n   * @return {bool} True if this resembles a promise\n   */\n\n\n  function thatLooksLikeAPromiseToMe(o) {\n    return o && typeof o.then === \"function\" && typeof o.catch === \"function\";\n  }\n  /**\n   * promisify()\n   *\n   * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n   * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n   * and rejects when `error` is truthy. You can also supply settings object as the second argument.\n   *\n   * @param {function} original - The function to promisify\n   * @param {object} settings - Settings object\n   * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`\n   * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?\n   * @return {function} A promisified version of `original`\n   */\n\n\n  return function promisify(original, settings) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var returnMultipleArguments = settings && settings.multiArgs;\n      var target = void 0;\n\n      if (settings && settings.thisArg) {\n        target = settings.thisArg;\n      } else if (settings) {\n        target = settings;\n      } // Return the promisified function\n\n\n      return new ES6Promise(function (resolve, reject) {\n        // Append the callback bound to the context\n        args.push(function callback(err) {\n          if (err) {\n            return reject(err);\n          }\n\n          for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            values[_key2 - 1] = arguments[_key2];\n          }\n\n          if (false === !!returnMultipleArguments) {\n            return resolve(values[0]);\n          }\n\n          resolve(values);\n        }); // Call the function\n\n        var response = original.apply(target, args); // If it looks like original already returns a promise,\n        // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.\n\n        if (thatLooksLikeAPromiseToMe(response)) {\n          resolve(response);\n        }\n      });\n    };\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}