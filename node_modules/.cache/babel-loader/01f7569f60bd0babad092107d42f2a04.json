{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _regeneratorRuntime = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/sunnyd/Desktop/Weather App/subtube/node_modules/@babel/runtime/helpers/inherits\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto = require(\"crypto\");\n\nvar querystring = require(\"querystring\");\n\nvar stream = require(\"stream\");\n\nvar messages = require(\"../messages\");\n\nvar pemverifier_1 = require(\"./../pemverifier\");\n\nvar authclient_1 = require(\"./authclient\");\n\nvar loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar OAuth2Client =\n/*#__PURE__*/\nfunction (_authclient_1$AuthCli) {\n  _inherits(OAuth2Client, _authclient_1$AuthCli);\n\n  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri) {\n    var _this;\n\n    _classCallCheck(this, OAuth2Client);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OAuth2Client).call(this));\n    _this.certificateExpiry = null;\n    _this.refreshTokenPromises = new Map();\n    var opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret: clientSecret,\n      redirectUri: redirectUri\n    };\n    _this._clientId = opts.clientId;\n    _this._clientSecret = opts.clientSecret;\n    _this.redirectUri = opts.redirectUri;\n    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    return _this;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  _createClass(OAuth2Client, [{\n    key: \"generateAuthUrl\",\n    value: function generateAuthUrl() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (opts.code_challenge_method && !opts.code_challenge) {\n        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n      }\n\n      opts.response_type = opts.response_type || 'code';\n      opts.client_id = opts.client_id || this._clientId;\n      opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n      if (opts.scope instanceof Array) {\n        opts.scope = opts.scope.join(' ');\n      }\n\n      var rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n      return rootUrl + '?' + querystring.stringify(opts);\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     */\n\n  }, {\n    key: \"generateCodeVerifier\",\n    value: function generateCodeVerifier() {\n      // base64 encoding uses 6 bits per character, and we want to generate128\n      // characters. 6*128/8 = 96.\n      var randomString = crypto.randomBytes(96).toString('base64'); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n      // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n      // swapping out a few chars.\n\n      var codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n      var unencodedCodeChallenge = crypto.createHash('sha256').update(codeVerifier).digest('base64'); // We need to use base64UrlEncoding instead of standard base64\n\n      var codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n      return {\n        codeVerifier: codeVerifier,\n        codeChallenge: codeChallenge\n      };\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken(codeOrOptions, callback) {\n      var options = typeof codeOrOptions === 'string' ? {\n        code: codeOrOptions\n      } : codeOrOptions;\n\n      if (callback) {\n        this.getTokenAsync(options).then(function (r) {\n          return callback(null, r.tokens, r.res);\n        }, function (e) {\n          return callback(e, null, e.response);\n        });\n      } else {\n        return this.getTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"getTokenAsync\",\n    value: function getTokenAsync(options) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var url, values, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                values = {\n                  code: options.code,\n                  client_id: options.client_id || this._clientId,\n                  client_secret: this._clientSecret,\n                  redirect_uri: options.redirect_uri || this.redirectUri,\n                  grant_type: 'authorization_code',\n                  code_verifier: options.codeVerifier\n                };\n                _context.next = 4;\n                return this.transporter.request({\n                  method: 'POST',\n                  url: url,\n                  data: querystring.stringify(values),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 4:\n                res = _context.sent;\n                tokens = res.data;\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context.abrupt(\"return\", {\n                  tokens: tokens,\n                  res: res\n                });\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken(_refreshToken) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var p;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (_refreshToken) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.refreshTokenNoCache(_refreshToken));\n\n              case 2:\n                if (!this.refreshTokenPromises.has(_refreshToken)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.refreshTokenPromises.get(_refreshToken));\n\n              case 4:\n                p = this.refreshTokenNoCache(_refreshToken).then(function (r) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  return r;\n                }, function (e) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  throw e;\n                });\n                this.refreshTokenPromises.set(_refreshToken, p);\n                return _context2.abrupt(\"return\", p);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"refreshTokenNoCache\",\n    value: function refreshTokenNoCache(refreshToken) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        var url, data, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                data = {\n                  refresh_token: refreshToken,\n                  client_id: this._clientId,\n                  client_secret: this._clientSecret,\n                  grant_type: 'refresh_token'\n                }; // request for new token\n\n                _context3.next = 4;\n                return this.transporter.request({\n                  method: 'POST',\n                  url: url,\n                  data: querystring.stringify(data),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 4:\n                res = _context3.sent;\n                tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context3.abrupt(\"return\", {\n                  tokens: tokens,\n                  res: res\n                });\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(callback) {\n      messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n\n      if (callback) {\n        this.refreshAccessTokenAsync().then(function (r) {\n          return callback(null, r.credentials, r.res);\n        }, callback);\n      } else {\n        return this.refreshAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function refreshAccessTokenAsync() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var r, tokens;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.credentials.refresh_token) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('No refresh token is set.');\n\n              case 2:\n                _context4.next = 4;\n                return this.refreshToken(this.credentials.refresh_token);\n\n              case 4:\n                r = _context4.sent;\n                tokens = r.tokens;\n                tokens.refresh_token = this.credentials.refresh_token;\n                this.credentials = tokens;\n                return _context4.abrupt(\"return\", {\n                  credentials: this.credentials,\n                  res: r.res\n                });\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken(callback) {\n      if (callback) {\n        this.getAccessTokenAsync().then(function (r) {\n          return callback(null, r.token, r.res);\n        }, callback);\n      } else {\n        return this.getAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"getAccessTokenAsync\",\n    value: function getAccessTokenAsync() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        var shouldRefresh, r;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n                if (!(shouldRefresh && this.credentials.refresh_token)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                if (this.credentials.refresh_token) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new Error('No refresh token is set.');\n\n              case 4:\n                _context5.next = 6;\n                return this.refreshAccessTokenAsync();\n\n              case 6:\n                r = _context5.sent;\n\n                if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw new Error('Could not refresh access token.');\n\n              case 9:\n                return _context5.abrupt(\"return\", {\n                  token: r.credentials.access_token,\n                  res: r.res\n                });\n\n              case 12:\n                return _context5.abrupt(\"return\", {\n                  token: this.credentials.access_token\n                });\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"getRequestMetadata\",\n    value: function getRequestMetadata(url, callback) {\n      messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n\n      if (callback) {\n        this.getRequestMetadataAsync(url).then(function (r) {\n          return callback(null, r.headers, r.res);\n        }, callback);\n      } else {\n        return this.getRequestMetadataAsync();\n      }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function getRequestHeaders(url) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getRequestMetadataAsync(url);\n\n              case 2:\n                res = _context6.sent;\n                return _context6.abrupt(\"return\", res.headers);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"getRequestMetadataAsync\",\n    value: function getRequestMetadataAsync(url) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        var thisCreds, _headers, r, tokens, e, credentials, headers;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                thisCreds = this.credentials;\n\n                if (!(!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey)) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw new Error('No access, refresh token or API key is set.');\n\n              case 3:\n                if (!(thisCreds.access_token && !this.isTokenExpiring())) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                _headers = {\n                  Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n                };\n                return _context7.abrupt(\"return\", {\n                  headers: _headers\n                });\n\n              case 7:\n                if (!this.apiKey) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  headers: {}\n                });\n\n              case 9:\n                r = null;\n                tokens = null;\n                _context7.prev = 11;\n                _context7.next = 14;\n                return this.refreshToken(thisCreds.refresh_token);\n\n              case 14:\n                r = _context7.sent;\n                tokens = r.tokens;\n                _context7.next = 23;\n                break;\n\n              case 18:\n                _context7.prev = 18;\n                _context7.t0 = _context7[\"catch\"](11);\n                e = _context7.t0;\n\n                if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                  e.message = 'Could not refresh access token.';\n                }\n\n                throw e;\n\n              case 23:\n                credentials = this.credentials;\n                credentials.token_type = credentials.token_type || 'Bearer';\n                tokens.refresh_token = credentials.refresh_token;\n                this.credentials = tokens;\n                headers = {\n                  Authorization: credentials.token_type + ' ' + tokens.access_token\n                };\n                return _context7.abrupt(\"return\", {\n                  headers: headers,\n                  res: r.res\n                });\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[11, 18]]);\n      }));\n    }\n  }, {\n    key: \"revokeToken\",\n    value: function revokeToken(token, callback) {\n      var opts = {\n        url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' + querystring.stringify({\n          token: token\n        }),\n        method: 'POST'\n      };\n\n      if (callback) {\n        this.transporter.request(opts).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.transporter.request(opts);\n      }\n    }\n  }, {\n    key: \"revokeCredentials\",\n    value: function revokeCredentials(callback) {\n      if (callback) {\n        this.revokeCredentialsAsync().then(function (res) {\n          return callback(null, res);\n        }, callback);\n      } else {\n        return this.revokeCredentialsAsync();\n      }\n    }\n  }, {\n    key: \"revokeCredentialsAsync\",\n    value: function revokeCredentialsAsync() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8() {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                token = this.credentials.access_token;\n                this.credentials = {};\n\n                if (!token) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.revokeToken(token));\n\n              case 6:\n                throw new Error('No access token to revoke.');\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n  }, {\n    key: \"requestAsync\",\n    value: function requestAsync(opts) {\n      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        var r2, r, res, statusCode, mayRequireRefresh, isReadableStream, isAuthErr;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.getRequestMetadataAsync(opts.url);\n\n              case 3:\n                r = _context9.sent;\n\n                if (r.headers && r.headers.Authorization) {\n                  opts.headers = opts.headers || {};\n                  opts.headers.Authorization = r.headers.Authorization;\n                }\n\n                if (this.apiKey) {\n                  opts.params = Object.assign(opts.params || {}, {\n                    key: this.apiKey\n                  });\n                }\n\n                _context9.next = 8;\n                return this.transporter.request(opts);\n\n              case 8:\n                r2 = _context9.sent;\n                _context9.next = 24;\n                break;\n\n              case 11:\n                _context9.prev = 11;\n                _context9.t0 = _context9[\"catch\"](0);\n                res = _context9.t0.response;\n\n                if (!res) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but no\n                //   expiry_date was availabe. This can happen when developers stash\n                //   the access_token and refresh_token for later use, but the\n                //   access_token fails on the first try because it's expired.\n\n                mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && !this.credentials.expiry_date;\n                isReadableStream = res.config.data instanceof stream.Readable;\n                isAuthErr = statusCode === 401 || statusCode === 403;\n\n                if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                _context9.next = 22;\n                return this.refreshAccessTokenAsync();\n\n              case 22:\n                return _context9.abrupt(\"return\", this.requestAsync(opts, true));\n\n              case 23:\n                throw _context9.t0;\n\n              case 24:\n                return _context9.abrupt(\"return\", r2);\n\n              case 25:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 11]]);\n      }));\n    }\n  }, {\n    key: \"verifyIdToken\",\n    value: function verifyIdToken(options, callback) {\n      // This function used to accept two arguments instead of an options object.\n      // Check the types to help users upgrade with less pain.\n      // This check can be removed after a 2.0 release.\n      if (callback && typeof callback !== 'function') {\n        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n      }\n\n      if (callback) {\n        this.verifyIdTokenAsync(options).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.verifyIdTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"verifyIdTokenAsync\",\n    value: function verifyIdTokenAsync(options) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10() {\n        var response, login;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (options.idToken) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('The verifyIdToken method requires an ID Token');\n\n              case 2:\n                _context10.next = 4;\n                return this.getFederatedSignonCertsAsync();\n\n              case 4:\n                response = _context10.sent;\n                login = this.verifySignedJwtWithCerts(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n                return _context10.abrupt(\"return\", login);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n\n  }, {\n    key: \"getTokenInfo\",\n    value: function getTokenInfo(accessToken) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11() {\n        var _ref, data, info;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.transporter.request({\n                  method: 'GET',\n                  url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n                  params: {\n                    access_token: accessToken\n                  }\n                });\n\n              case 2:\n                _ref = _context11.sent;\n                data = _ref.data;\n                info = Object.assign({\n                  expiry_date: new Date().getTime() + data.expires_in * 1000,\n                  scopes: data.scope.split(' ')\n                }, data);\n                delete info.expires_in;\n                delete info.scope;\n                return _context11.abrupt(\"return\", info);\n\n              case 8:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"getFederatedSignonCerts\",\n    value: function getFederatedSignonCerts(callback) {\n      if (callback) {\n        this.getFederatedSignonCertsAsync().then(function (r) {\n          return callback(null, r.certs, r.res);\n        }, callback);\n      } else {\n        return this.getFederatedSignonCertsAsync();\n      }\n    }\n  }, {\n    key: \"getFederatedSignonCertsAsync\",\n    value: function getFederatedSignonCertsAsync() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12() {\n        var nowTime, res, cacheControl, cacheAge, pattern, regexResult, now;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                nowTime = new Date().getTime();\n\n                if (!(this.certificateExpiry && nowTime < this.certificateExpiry.getTime())) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  certs: this.certificateCache\n                });\n\n              case 3:\n                _context12.prev = 3;\n                _context12.next = 6;\n                return this.transporter.request({\n                  url: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_\n                });\n\n              case 6:\n                res = _context12.sent;\n                _context12.next = 12;\n                break;\n\n              case 9:\n                _context12.prev = 9;\n                _context12.t0 = _context12[\"catch\"](3);\n                throw new Error('Failed to retrieve verification certificates: ' + _context12.t0);\n\n              case 12:\n                cacheControl = res ? res.headers['cache-control'] : undefined;\n                cacheAge = -1;\n\n                if (cacheControl) {\n                  pattern = new RegExp('max-age=([0-9]*)');\n                  regexResult = pattern.exec(cacheControl);\n\n                  if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                  }\n                }\n\n                now = new Date();\n                this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n                this.certificateCache = res.data;\n                return _context12.abrupt(\"return\", {\n                  certs: res.data,\n                  res: res\n                });\n\n              case 19:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[3, 9]]);\n      }));\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a LoginTicket on verification.\n     */\n\n  }, {\n    key: \"verifySignedJwtWithCerts\",\n    value: function verifySignedJwtWithCerts(jwt, certs, requiredAudience, issuers, maxExpiry) {\n      if (!maxExpiry) {\n        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n      }\n\n      var segments = jwt.split('.');\n\n      if (segments.length !== 3) {\n        throw new Error('Wrong number of segments in token: ' + jwt);\n      }\n\n      var signed = segments[0] + '.' + segments[1];\n      var signature = segments[2];\n      var envelope;\n      var payload;\n\n      try {\n        envelope = JSON.parse(this.decodeBase64(segments[0]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      if (!envelope) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      try {\n        payload = JSON.parse(this.decodeBase64(segments[1]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token payload: ' + segments[0]);\n      }\n\n      if (!payload) {\n        throw new Error('Can\\'t parse token payload: ' + segments[1]);\n      }\n\n      if (!certs.hasOwnProperty(envelope.kid)) {\n        // If this is not present, then there's no reason to attempt verification\n        throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n      }\n\n      var pem = certs[envelope.kid];\n      var pemVerifier = new pemverifier_1.PemVerifier();\n      var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n      if (!verified) {\n        throw new Error('Invalid token signature: ' + jwt);\n      }\n\n      if (!payload.iat) {\n        throw new Error('No issue time in token: ' + JSON.stringify(payload));\n      }\n\n      if (!payload.exp) {\n        throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n      }\n\n      var iat = Number(payload.iat);\n      if (isNaN(iat)) throw new Error('iat field using invalid format');\n      var exp = Number(payload.exp);\n      if (isNaN(exp)) throw new Error('exp field using invalid format');\n      var now = new Date().getTime() / 1000;\n\n      if (exp >= now + maxExpiry) {\n        throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n      }\n\n      var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n      var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n      if (now < earliest) {\n        throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n      }\n\n      if (now > latest) {\n        throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n      }\n\n      if (issuers && issuers.indexOf(payload.iss) < 0) {\n        throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n      } // Check the audience matches if we have one\n\n\n      if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n        var aud = payload.aud;\n        var audVerified = false; // If the requiredAudience is an array, check if it contains token\n        // audience\n\n        if (requiredAudience.constructor === Array) {\n          audVerified = requiredAudience.indexOf(aud) > -1;\n        } else {\n          audVerified = aud === requiredAudience;\n        }\n\n        if (!audVerified) {\n          throw new Error('Wrong recipient, payload audience != requiredAudience');\n        }\n      }\n\n      return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * This is a utils method to decode a base64 string\n     * @param b64String The string to base64 decode\n     * @return The decoded string\n     */\n\n  }, {\n    key: \"decodeBase64\",\n    value: function decodeBase64(b64String) {\n      var buffer = Buffer.from(b64String, 'base64');\n      return buffer.toString('utf8');\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n\n  }, {\n    key: \"isTokenExpiring\",\n    value: function isTokenExpiring() {\n      var expiryDate = this.credentials.expiry_date;\n      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n  }]);\n\n  return OAuth2Client;\n}(authclient_1.AuthClient);\n\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;","map":null,"metadata":{},"sourceType":"script"}