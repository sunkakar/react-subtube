{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar axios_1 = require(\"axios\");\n/**\n * Attach the interceptor to the Axios instance.\n * @param instance The optional Axios instance on which to attach the\n * interceptor.\n * @returns The id of the interceptor attached to the axios instance.\n */\n\n\nfunction attach(instance) {\n  instance = instance || axios_1.default;\n  return instance.interceptors.response.use(onFulfilled, onError);\n}\n\nexports.attach = attach;\n/**\n * Eject the Axios interceptor that is providing retry capabilities.\n * @param interceptorId The interceptorId provided in the config.\n * @param instance The axios instance using this interceptor.\n */\n\nfunction detach(interceptorId, instance) {\n  instance = instance || axios_1.default;\n  instance.interceptors.response.eject(interceptorId);\n}\n\nexports.detach = detach;\n\nfunction onFulfilled(res) {\n  return res;\n}\n\nfunction onError(err) {\n  var config = err.config.raxConfig || {};\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;\n  config.retryDelay = config.retryDelay || 100;\n  config.instance = config.instance || axios_1.default;\n  config.httpMethodsToRetry = config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];\n  config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries; // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n  var retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n  // 1xx - Retry (Informational, request still processing)\n  // 2xx - Do not retry (Success)\n  // 3xx - Do not retry (Redirect)\n  // 4xx - Do not retry (Client errors)\n  // 429 - Retry (\"Too Many Requests\")\n  // 5xx - Retry (Server errors)\n  [100, 199], [429, 429], [500, 599]];\n  config.statusCodesToRetry = config.statusCodesToRetry || retryRanges; // Put the config back into the err\n\n  err.config.raxConfig = config; // Determine if we should retry the request\n\n  var shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n\n  if (!shouldRetryFn(err)) {\n    return Promise.reject(err);\n  } // Calculate time to wait with exponential backoff.\n  // Formula: (2^c - 1 / 2) * 1000\n\n\n  var delay = (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000; // We're going to retry!  Incremenent the counter.\n\n  err.config.raxConfig.currentRetryAttempt += 1; // Create a promise that invokes the retry after the backOffDelay\n\n  var backoff = new Promise(function (resolve) {\n    setTimeout(resolve, delay);\n  }); // Notify the user if they added an `onRetryAttempt` handler\n\n  if (config.onRetryAttempt) {\n    config.onRetryAttempt(err);\n  } // Return the promise in which recalls axios to retry the request\n\n\n  return backoff.then(function () {\n    return config.instance.request(err.config);\n  });\n}\n/**\n * Determine based on config if we should retry the request.\n * @param err The AxiosError passed to the interceptor.\n */\n\n\nfunction shouldRetryRequest(err) {\n  var config = err.config.raxConfig; // If there's no config, or retries are disabled, return.\n\n  if (!config || config.retry === 0) {\n    return false;\n  } // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n\n\n  if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n    return false;\n  } // Only retry with configured HttpMethods.\n\n\n  if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n    return false;\n  } // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n\n  if (err.response && err.response.status) {\n    var isInRange = false;\n\n    for (var _i = 0, _a = config.statusCodesToRetry; _i < _a.length; _i++) {\n      var _b = _a[_i],\n          min = _b[0],\n          max = _b[1];\n      var status = err.response.status;\n\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n\n    if (!isInRange) {\n      return false;\n    }\n  } // If we are out of retry attempts, return\n\n\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n\n  if (config.currentRetryAttempt >= config.retry) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Acquire the raxConfig object from an AxiosError if available.\n * @param err The Axios error with a config object.\n */\n\n\nfunction getConfig(err) {\n  if (err && err.config) {\n    return err.config.raxConfig;\n  }\n\n  return;\n}\n\nexports.getConfig = getConfig;","map":null,"metadata":{},"sourceType":"script"}